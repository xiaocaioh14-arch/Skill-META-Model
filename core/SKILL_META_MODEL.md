# 🧬 Skill 开发元模型 (Meta-Model)

> **基于 8 个实战 Skill 提炼的开发框架**
> 📅 生成日期: 2026-01-30
> 📅 最后更新: 2026-02-02 (革命性更新：新增"元认知与自我迭代"模式)
> 🎯 目标: 意图 → Skill 的高效转化
> ⭐ v2.0 - 系统具备自我认知和持续进化能力

---

## 一、核心发现：你的 Skill 开发 DNA

通过分析你开发的 7 个 Skill + 1 个元工具 Skill，我提炼出以下共性模式：

| Skill | 核心特征 | 关键创新点 |
|-------|---------|-----------|
| **每日线路资源日报** | 静默执行 + 比价逻辑 + 双格式输出 | "The Matchmaker" 询价-报价匹配算法 |
| **PPT Generator Pro** | 阶段化工作流 + 多模态输出 | Claude 分析图片生成转场提示词 |
| **专属播客** | API 链式调用 + 浏览器自动化 | Playwright 持久化登录 |
| **邮件汇总表格** | AI Fallback 机制 + 外部同步 | 正则失败 → AI 提取的降级策略 |
| **论文解读 Skills** | 2026 前沿设计规范 + 自适应长度 | 径向思维导图 HTML 组件 |
| **海外运营商多维解析** 🆕 | 双报告架构 + 多层估算 + 加权评分 | 4层IEPL估算模型 + 5文件输出 |
| **组织文化分析师** 🆕 | 纯Prompt + 四维光谱 + 场景重构 | 基于事实的场景重构方法论 |
| **元模型更新器** 🆕⭐ | 元认知 + 自我迭代 + 智能去重 | 6维度分析 + 相似度计算 + 通用性评分 |

### 你的开发风格特征

```
┌─────────────────────────────────────────────────────────┐
│  🧙‍♂️ Eddie 的 Skill 开发哲学                              │
├─────────────────────────────────────────────────────────┤
│  1. 静默优先 — 不打断用户，一次性完整输出                    │
│  2. 双格式标配 — MD + HTML/PDF 始终成对出现                 │
│  3. 脚本分离 — 脏活累活交给 Python，Claude 专注智能处理      │
│  4. 优雅降级 — 正则 → AI Fallback → 人工兜底                │
│  5. 视觉极致 — 2026 前沿设计，毛玻璃/渐变/动效              │
│  6. 多视角输出 — 同一数据生成不同受众的专属报告 🆕           │
│  7. 数据质量追踪 — 每个维度标注来源和置信度 🆕              │
│  8. 模板驱动 — 使用详细模板确保输出一致性 🆕                │
│  9. 场景重构 — 基于事实还原场景，而非机械提取 🆕⭐          │
└─────────────────────────────────────────────────────────┘
```

---

## 二、四阶段开发流程 (The Eddie Method)

### Phase 1: 启发式探索 (Heuristic Discovery)

**目标**: 挖掘真实需求，找到自动化阻塞点

```markdown
## 探索清单
- [ ] 用户的原始意图是什么？
- [ ] 当前手动流程有哪些步骤？
- [ ] 哪些步骤可以完全自动化？
- [ ] 哪些步骤需要人工确认？（尽量消除）
- [ ] 需要哪些外部 API/工具？
- [ ] 输入数据从哪里来？格式是什么？
- [ ] 输出期望是什么？（文件类型、格式、位置）
```

**实战经验**:
> "邮件汇总" Skill 的阻塞点：IMAP 连接复杂 → 解决方案：封装为 `fetch_emails.py` 脚本

### Phase 2: 技能蓝图 (Skill Blueprint)

**目标**: 定义精确的输入/输出契约和自动化逻辑

```markdown
# Skill Blueprint: {Skill 名称}

## 1. Skill Identity
- **Name**: `{skill-name-in-kebab-case}`
- **Description**: {一句话描述}
- **Trigger Strategy**:
  - **Slash Command**: `/{command}`
  - **Semantic Triggers**: "{触发短语1}" / "{触发短语2}"

## 2. Input/Output Contract
- **Input (Injectable Variables)**:
  - `VAR_1`: {描述}
  - `VAR_2`: {描述}
  
- **Output (Strict Format)**:
  1. **File 1**: `{filename}.md` — {内容描述}
  2. **File 2**: `{filename}.html` — {内容描述}
  3. **Terminal**: {简明日志}

## 3. Automation Logic (Zero-Touch)
### A. 数据处理逻辑
{描述核心算法}

### B. 错误处理逻辑
{描述降级策略}

## 4. Workflow Steps
1. Step 1: {动作}
2. Step 2: {动作}
...

## 5. Artifacts to Create
- `SKILL.md`: 核心指令
- `scripts/{name}.py`: 辅助脚本
```

### Phase 3: 编写 SKILL.md (Authoring)

**目标**: 创建可执行的 Skill 定义文件

**标准模板** (见下一节)

### Phase 4: 验证 (Validation)

**目标**: 确保 Skill 在各种场景下稳定运行

```markdown
## 验证矩阵

| 测试场景 | 输入 | 预期行为 | 通过标准 |
|---------|------|---------|---------|
| 正常流程 | {标准输入} | {预期输出} | ✅ {验收条件} |
| 边缘情况 | {异常输入} | {降级处理} | ✅ {验收条件} |
| 错误输入 | {无效输入} | {优雅终止} | ✅ {验收条件} |
| 空数据 | {空输入} | {空报告} | ✅ 不报错退出 |
```

---

## 三、SKILL.md 标准模板


```markdown
---
name: {skill-name}
description: {一句话描述功能}
license: MIT
triggers:
  - {触发短语1}
  - {触发短语2}
slash_commands:
  - command: /{command}
    description: {命令描述}
    usage: /{command} {参数}
---

# 📦 {Skill 中文名称}

## 🔇 静默执行协议 (Quiet Mode Protocol)

> [!CRITICAL]
> **必须严格遵守以下原子性执行原则：**
>
> 1. **禁止中途询问** — 不要问"是否继续？"、"需要确认吗？"
> 2. **一次性完整输出** — 收到输入后，一口气生成所有内容
> 3. **静默决策** — 遇到多选项时，自动选择最合理的默认值
> 4. **错误静默处理** — 错误信息填入备注栏，不中断流程
> 5. **缺失即终止** — 仅在"关键资源不可用"时终止并说明

---

## 1. 环境与依赖

### 环境变量
| 变量名 | 必需 | 说明 |
|--------|------|------|
| `{VAR_1}` | ✅ | {说明} |
| `{VAR_2}` | ❌ | {说明} |

### Python 依赖
\`\`\`bash
pip install {package1} {package2}
\`\`\`

---

## 2. 工作流逻辑

### Step 1: {步骤名称}
{详细描述}

\`\`\`bash
{示例命令}
\`\`\`

### Step 2: {步骤名称}
{详细描述}

### Step 3: 生成报告
**语言**: 中文 (Simplified Chinese)
**格式**: Markdown + HTML

---

## 3. 核心算法

### 数据提取字段
| 字段 | 说明 | 示例 |
|------|------|------|
| `field_1` | {说明} | {示例} |
| `field_2` | {说明} | {示例} |

### 处理逻辑
{描述核心算法，如比价、匹配、分类等}

### 错误处理
| 场景 | 处理方式 |
|------|---------|
| 缺失字段 | 填 `N/A`，备注说明 |
| 解析失败 | 追加到 "Unprocessed" 章节 |
| 空数据 | 生成空报告，不报错 |

---

## 4. Few-Shot 示例

### ✅ Good Case
*Input*: {示例输入}
*Action*: {正确处理}
*Output*: {预期输出}

### ❌ Anti-Pattern
*Bad Behavior*: {错误做法}
*Why Wrong*: {为什么错误}
*Correct Behavior*: {正确做法}

---

## 5. 输出规范

### 文件命名
- `{output_name}_{YYYY-MM-DD}.md`
- `{output_name}_{YYYY-MM-DD}.html`

### 最终输出
执行完成后，仅输出：
\`\`\`
✅ {Skill 名称} 执行完成：
- [MD] {path_to_md}
- [HTML] {path_to_html}
\`\`\`
```

---

## 四、关键设计模式

### 模式 1: 静默执行协议 (Silent Execution Protocol)

**应用于**: 所有 5 个 Skill

```python
# 伪代码
def execute_skill(input):
    try:
        result = process(input)
        if result.has_warnings:
            result.remarks.append(warnings)  # 不中断
        return generate_report(result)
    except CriticalError as e:
        return f"❌ 终止: {e.message}"  # 仅关键错误才终止
    except Exception as e:
        result.remarks.append(f"处理异常: {e}")
        return generate_report(result)  # 继续执行
```

**你的实战案例**:
> 邮件汇总 Skill：邮件解析失败时，填入备注栏 "Missing critical fields"，不中断整体流程

---

### 模式 2: AI Fallback 降级机制

**应用于**: 邮件汇总表格

```
正则提取 → 失败 → AI 提取 → 失败 → 人工兜底
   ↓              ↓              ↓
 成功返回      成功返回      填 N/A + 备注
```

**实现代码片段**:
```python
def extract_field(text, field_name):
    # 第一层：正则
    result = regex_extract(text, field_name)
    if result != "未提及":
        return result
    
    # 第二层：AI Fallback
    result = ai_extract(text, field_name)
    if result:
        return result
    
    # 第三层：人工兜底
    return "N/A (需人工核查)"
```

---

### 模式 3: 双格式输出标配

**应用于**: 所有 5 个 Skill

| Skill | Markdown | HTML/PDF | 原因 |
|-------|----------|----------|------|
| 邮件日报 | ✅ | ✅ HTML | 便于分享 + 暗黑模式 |
| PPT Generator | ✅ JSON | ✅ HTML 播放器 | 交互式体验 |
| 论文解读 | ✅ | ✅ HTML + PDF | 2026 前沿设计 |

**设计原则**:
- **MD**: 便于 Git 版本控制、AI 再处理
- **HTML**: 便于人类阅读、分享、打印

---

### 模式 4: 脚本分离架构

**应用于**: 邮件日报、邮件表格、PPT Generator

```
┌─────────────────────────────────────────┐
│           SKILL.md (Claude 指令)         │
│  - 智能分析                              │
│  - 内容规划                              │
│  - 报告生成                              │
└─────────────────┬───────────────────────┘
                  │ 调用
                  ▼
┌─────────────────────────────────────────┐
│         scripts/*.py (脏活累活)          │
│  - IMAP 连接                            │
│  - API 调用                             │
│  - 文件 I/O                             │
└─────────────────────────────────────────┘
```

**原则**: Claude 专注智能处理，机械操作交给脚本

---

### 模式 5: 阶段化工作流

**应用于**: PPT Generator Pro (最复杂的示例)

```
Phase 1: 收集输入
    ├── 获取文档内容
    ├── 选择风格
    ├── 选择页数
    └── 选择分辨率

Phase 2: 内容规划
    ├── 分析文档
    └── 生成 slides_plan.json

Phase 3: 生成图片
    ├── 调用 Nano Banana Pro
    └── 监控进度

Phase 4: 生成转场 (可选)
    ├── Claude 分析图片差异
    ├── 生成转场提示词
    └── 调用可灵 AI

Phase 5: 合成输出
    ├── 交互式播放器
    └── 完整视频
```

---

### 模式 6: 双报告架构 🆕

**应用于**: 海外运营商多维解析 Skill

**核心思想**: 同一份数据，针对不同受众生成不同视角的报告

```
                    ┌─→ 报告1: 综合分析 (10维度)
                    │   目标: 投资者、战略部门
用户输入 → 数据采集 ─┤   风格: 深色科技风
                    │
                    └─→ 报告2: 批发业务分析
                        目标: 采购、BD团队
                        风格: 商务蓝色风
```

**输出结构（5文件）**:
```
reports/
├── {名称}_{日期}_综合分析.html      # 报告1 HTML
├── {名称}_{日期}_综合分析.md        # 报告1 MD
├── {名称}_{日期}_批发业务分析.html  # 报告2 HTML
├── {名称}_{日期}_批发业务分析.md    # 报告2 MD
└── {名称}_{日期}_原始数据.json      # 原始数据
```

**适用场景**:
- 同一数据需要服务不同角色（如技术 vs 商务）
- 需要保留原始数据供二次分析
- 不同报告需要不同的视觉风格

---

### 模式 7: 多层估算模型 🆕

**应用于**: 海外运营商多维解析 Skill（IEPL占比估算）

**核心思想**: 当数据缺失时，使用多层降级策略逐步估算

```
层级1: 直接提取（最优）
   ↓ (失败)
层级2: 关联推算（如：批发业务收入 × 60%）
   ↓ (失败)
层级3: 行业对标（按公司类型取平均值）
   ↓ (失败)
层级4: AI 综合推理（基于多因子评分）
```

**实现代码**:
```python
def estimate_iepl_ratio(carrier_data):
    # 层级1: 直接提取
    if "iepl_ratio" in carrier_data:
        return {"ratio": carrier_data["iepl_ratio"], "confidence": "high (95%)"}
    
    # 层级2: 批发业务推算
    if "wholesale_pct" in carrier_data:
        ratio = carrier_data["wholesale_pct"] * 0.65
        return {"ratio_range": f"{ratio*0.8:.0f}-{ratio*1.2:.0f}%", "confidence": "medium (75%)"}
    
    # 层级3: 行业对标
    benchmarks = {"Tier1": "15-25%", "区域": "5-10%", "移动": "2-5%"}
    company_type = classify_carrier(carrier_data)
    return {"ratio_range": benchmarks[company_type], "confidence": "medium (65%)"}
    
    # 层级4: AI综合推理
    score = calculate_iepl_score(carrier_data)  # 基于海缆、PoP、企业客户
    return {"ratio_range": score_to_ratio(score), "confidence": "low (50%)"}
```

**关键要素**:
- 每层都有明确的触发条件和置信度
- 估算结果必须标注**置信度**和**估算依据**
- 用户可以看到估算是如何得出的

---

### 模式 8: 加权评分系统 🆕

**应用于**: 海外运营商多维解析 Skill（资源稀缺性评分）

**核心思想**: 将多维度定性分析转化为可比较的量化评分

```
总分 = Σ(维度评分 × 权重)

维度配置:
┌────────────────────┬────────┬────────┐
│ 维度               │ 权重   │ 评分   │
├────────────────────┼────────┼────────┤
│ 海缆资源           │ 35%    │ ⭐⭐⭐⭐⭐ │
│ IEPL/本地接入      │ 30%    │ ⭐⭐⭐⭐  │
│ 批发业务成熟度     │ 20%    │ ⭐⭐⭐⭐  │
│ 技术创新           │ 10%    │ ⭐⭐⭐   │
│ 财务稳定性         │ 5%     │ ⭐⭐⭐⭐  │
├────────────────────┼────────┼────────┤
│ 加权总分           │ 100%   │ 4.15   │
└────────────────────┴────────┴────────┘
```

**评级映射**:
```python
def score_to_rating(score):
    if score >= 90: return "S (行业领导者)"
    if score >= 80: return "A (稳健增长型)"
    if score >= 70: return "B (平稳发展型)"
    if score >= 60: return "C (面临挑战)"
    return "D (需警惕风险)"
```

**适用场景**:
- 需要对复杂对象进行综合评估
- 需要支持多对象横向对比
- 需要将主观判断转化为客观评分

---

### 模式 9: 模板驱动报告 🆕

**应用于**: 海外运营商多维解析 Skill

**核心思想**: 使用详细的 Markdown 模板确保输出结构一致

```
templates/
├── analysis_template.md     # 综合分析模板
└── wholesale_template.md    # 批发业务模板（434行详细结构）
```

**模板结构示例**:
```markdown
# [运营商名称] - 批发业务分析报告

## 执行摘要
[AI 填充核心发现]

## 一、运营商概览
| 项目 | 数据 |
|------|------|
| **批发年收入** | [AI 填充] |
| **服务客户数** | [AI 填充] |

## 二、海缆资源分析 ⭐
### 2.1 自有海缆能力
[AI 按模板结构填充]

### 2.2 海缆项目参与
| 海缆名称 | 路由 | 长度 | 参与方式 |
|---------|------|------|---------|
| [AI 填充] | | | |

...（后续章节）
```

**优势**:
- 保证每次输出结构一致
- 便于多报告横向对比
- 减少 AI 发挥空间，提高可靠性
- 新人也能快速理解报告结构

---

### 模式 10: 基于事实的场景重构 🆕⭐

**应用于**: org-culture-analyst + 所有对话类内容分析

**核心思想**:
> 深度理解对话后，基于事实还原整个对话场景、关系动态和情感氛围，而非机械地逐字提取文本。

**设计哲学**:
- **不是"提取"，而是"重构"**
- **不是"摘录"，而是"还原"**
- **不是"记录"，而是"理解"**

**三大原则**:
1. **忠于事实** - 所有重构必须有原文依据，不添加臆想细节
2. **还原场景** - 重现对话的张力、转折、氛围
3. **保持客观** - 不做价值判断，不臆测动机

**实现框架**:
```
重构的四个维度:
├─ 对话张力 (分歧、转折、共识)
├─ 关系动态 (权力、立场、情感)
├─ 情感氛围 (紧张、协作、急迫)
└─ 决策逻辑 (问题→讨论→决策)
```

**对比示例**:

❌ **简单提取（机械）**:
```markdown
项目经理："我们可以用A方案"
技术负责人："A方案有风险"
领导："我觉得可以试试"
```

✅ **场景重构（智能）**:
```markdown
会议进入方案选择环节。项目经理率先提出了A方案，展现出主动
推进的姿态。但这一提议立即遭到了技术负责人的质疑，后者直接
指出了技术实现的风险。

此时出现了关键的决策节点。领导者介入讨论，用一句"我觉得可以
试试"定下了基调——鼓励创新尝试。技术负责人在领导表态后没有
继续坚持反对，显示出对层级决策的尊重。

> 事实依据：
> - "我们可以用A方案"（项目经理）
> - "A方案有风险"（技术负责人）
> - "我觉得可以试试"（领导）
```

**适用场景**（广泛）:
- 📝 会议记录分析
- 💬 聊天记录分析
- 📞 客服对话分析
- 🎤 用户访谈分析
- 📧 邮件往来分析
- 🤝 任何对话类内容

**防止过度重构的边界**:
| 可以做 ✅ | 不可以做 ❌ |
|---------|-----------|
| 还原对话的张力和转折 | 添加原文中不存在的情节 |
| 描述可观察的关系动态 | 臆测参与者的内心想法 |
| 基于用词推断情感氛围 | 编造参与者的动机和目的 |
| 整合分散的信息片段 | 改变参与者的原意 |

**可追溯性测试**:
> 重构的每一个描述，都应该能追溯到原文的某个细节

**核心指令模板**:
```markdown
你的任务不是逐字逐句提取对话内容，而是**深度理解后重构场景**。

1. 还原对话场景 - 谁在什么时刻说了什么？对话如何展开？
2. 呈现关系动态 - 权力关系如何体现？情感流动如何变化？
3. 保持客观忠实 - 所有描述必须基于原文事实
4. 标注事实依据 - 用引用块标注关键原文
```

**与其他模式的关系**:
- 融合了"静默执行协议"（模式 1）的流畅性
- 融合了"AI Fallback"（模式 2）的智能处理
- 超越了简单的"证据引用"，升华为"场景重构"
- 避免 AI 幻觉的同时，保持深度洞察

**为什么是最重要的模式之一**:
1. ✅ 适用范围最广（所有对话类内容）
2. ✅ 解决核心痛点（AI 幻觉 vs 机械提取）
3. ✅ 提升分析深度（从表面到场景）
4. ✅ 展现设计哲学（智能而不越界）

---

### 模式 11: 元认知与自我迭代 🆕⭐⭐

**应用于**: meta-model-updater（元模型更新器）

**核心思想**:
> 系统具备"自我认知"的能力，能够分析、理解并更新自己所属的知识体系。这是一种"元能力"——不是直接解决业务问题，而是让系统能够持续学习和进化。

**设计哲学**:
- **元认知** - 系统能够"思考自己的思考过程"
- **自我迭代** - 系统能够改进自己的知识库
- **持续进化** - 每次运行都让系统变得更智能

**三大核心能力**:

```
┌─────────────────────────────────────────┐
│           元认知与自我迭代               │
├─────────────────────────────────────────┤
│                                         │
│  1. 模式识别能力                         │
│     └─ 6大维度分析框架                   │
│        ├─ 工作流模式                     │
│        ├─ 算法模型                       │
│        ├─ 输出格式                       │
│        ├─ 错误处理                       │
│        ├─ 外部集成                       │
│        └─ 内容分析                       │
│                                         │
│  2. 相似度评估能力                       │
│     └─ 多维度相似度计算                  │
│        ├─ 核心特征 (40%)                 │
│        ├─ 场景重叠 (30%)                 │
│        └─ 实现逻辑 (30%)                 │
│                                         │
│  3. 自动去重能力                         │
│     └─ 智能判定新旧模式                  │
│        ├─ ≥0.85 → duplicate              │
│        ├─ 0.65-0.84 → variant            │
│        ├─ 0.45-0.64 → enhancement        │
│        └─ <0.45 → novel                  │
│                                         │
└─────────────────────────────────────────┘
```

**实现框架**:

```python
# 元认知核心算法

class MetaCognitionEngine:
    """元认知引擎：分析和更新知识系统"""

    def analyze_pattern(self, new_skill):
        """分析新 Skill 中的设计模式"""
        patterns = []

        # 6 大维度分析
        for dimension in self.dimensions:
            result = dimension.analyze(new_skill)
            if result.is_novel:
                patterns.append(result.pattern)

        return patterns

    def calculate_similarity(self, new_pattern, existing_patterns):
        """计算模式相似度"""
        similarities = {}

        for existing in existing_patterns:
            score = (
                self._compare_features(new_pattern, existing) * 0.4 +
                self._compare_scenarios(new_pattern, existing) * 0.3 +
                self._compare_implementation(new_pattern, existing) * 0.3
            )
            similarities[existing.name] = score

        return similarities

    def assess_generalizability(self, pattern):
        """评估模式的通用性"""
        score = 0

        # 场景数量 (40分)
        score += min(len(pattern.scenarios) / 5 * 40, 40)

        # 实现清晰度 (30分)
        if pattern.has_code_snippet:
            score += 30

        # 跨领域适用性 (20分)
        domains = len(set(s.domain for s in pattern.scenarios))
        score += min(domains / 3 * 20, 20)

        # 可追溯性 (10分)
        if pattern.source_skill and pattern.source_code:
            score += 10

        return score

    def update_knowledge_base(self, new_patterns):
        """更新知识库"""
        for pattern in new_patterns:
            # 自动去重
            if self._is_duplicate(pattern):
                continue

            # 添加到知识库
            self.knowledge_base.add(pattern)

            # 更新索引
            self.index.update(pattern)
```

**对比示例**:

❌ **传统做法（人工维护）**:
```
1. 开发新 Skill
2. 手动回顾是否有新模式
3. 人工决定是否更新文档
4. 手动编写模式描述
5. 容易遗忘或不一致

问题:
- 依赖人工记忆
- 质量参差不齐
- 容易重复添加
- 更新不及时
```

✅ **元认知模式（自动化）**:
```
1. 开发新 Skill
2. 触发: "更新元模型"
3. 自动分析 6 大维度
4. 自动计算相似度
5. 自动去重判断
6. 自动更新文档

优势:
- 零记忆负担
- 标准化流程
- 智能去重
- 实时更新
```

**适用场景**（广泛）:

- 📚 **Skill 开发** - 自动提取和更新设计模式库
- 💻 **代码库管理** - 自动识别和推广最佳实践
- 📖 **文档系统** - 自动构建和维护知识索引
- 🎨 **设计规范** - 自动同步设计模式库
- 🔧 **工具链优化** - 自动学习和改进工作流
- 📊 **数据流程** - 自动优化数据处理管道
- 🤖 **AI 系统** - 让 AI 系统能够"学习如何学习"

**实现代码**（通用性评分模型）:

```python
def assess_generalizability(pattern):
    """
    评估模式的通用性 (0-100分)

    返回:
        score (int): 通用性评分
        - ≥ 60: 值得添加
        - < 60: 不够通用
    """
    score = 0

    # 1. 适用场景数量 (40分)
    scenario_count = len(pattern.scenarios)
    if scenario_count >= 5:
        score += 40
    elif scenario_count >= 3:
        score += 30
    elif scenario_count >= 2:
        score += 15
    else:
        score += 5

    # 2. 实现清晰度 (30分)
    if pattern.has_pseudocode or pattern.has_code_snippet:
        score += 30
    elif pattern.has_clear_description:
        score += 15

    # 3. 跨领域适用性 (20分)
    domains = set([s.domain for s in pattern.scenarios])
    if len(domains) >= 3:
        score += 20
    elif len(domains) >= 2:
        score += 10

    # 4. 可追溯性 (10分)
    if pattern.source_skill and pattern.source_code:
        score += 10

    return score

# 使用示例
pattern = Pattern(
    name="元认知与自我迭代",
    scenarios=[
        Scenario("Skill开发", "技术领域"),
        Scenario("文档管理", "知识领域"),
        Scenario("设计规范", "设计领域"),
        Scenario("代码库维护", "技术领域"),
        Scenario("工作流优化", "流程领域"),
    ],
    has_code_snippet=True,
    source_skill="meta-model-updater",
    source_code="SKILL.md"
)

score = assess_generalizability(pattern)
# 输出: 100 (满分)
```

**与其他模式的关系**:

- 融合了 **"模式 5: 阶段化工作流"** 的多步骤流程
- 融合了 **"模式 8: 加权评分系统"** 的多维度评分
- 融合了 **"模式 10: 场景重构"** 的深度分析能力
- 超越了所有现有模式，是唯一具有 **"自我认知"** 的模式

**为什么是革命性的模式**:

1. ✅ **打破了"规则依赖记忆"的困局**
   - 之前: AI 需要记住规则 → 但 AI 没有记忆 → 规则形同虚设
   - 现在: 规则转化为可调用的 Skill → 只需记住触发词 → 随时可执行

2. ✅ **实现了"系统自我进化"的能力**
   - 每次运行都让知识库更完善
   - 系统会随着使用变得更智能
   - 知识的积累是自动化的

3. ✅ **建立了"质量保障"的机制**
   - 标准化的分析流程（6 大维度）
   - 智能的去重逻辑（避免重复）
   - 量化的评估标准（通用性评分）

4. ✅ **具有最广泛的适用性**
   - 不限于 Skill 开发
   - 可用于任何需要"自我学习"的系统
   - 是构建"自进化系统"的基础模式

5. ✅ **元认知的本质价值**
   - 这不是"做事"的模式，而是"学习做事"的模式
   - 这不是"解决问题"的工具，而是"学会解决问题"的能力
   - 这是从"工具"到"智能"的质变

**应用展望**:

```
当前应用:
  └─ Skill 元模型自动更新

未来可能:
  ├─ 代码库自动学习最佳实践
  ├─ 文档系统自动建立知识图谱
  ├─ 设计规范自动提取和传播
  ├─ 工作流自动优化和推荐
  └─ AI 系统的"元学习"能力

终极愿景:
  "让系统学会如何学习"
```

**使用建议**:

1. **明确知识边界** - 定义清晰的"知识域"，避免范围过大
2. **设计评估标准** - 确保有客观的"通用性"评判标准
3. **实现去重逻辑** - 避免知识库中的冗余和重复
4. **保持可追溯** - 每个知识点都能追溯到来源
5. **定期清理** - 删除过时或不再适用的模式

---

## 五、意图 → Skill 转化引擎


### 使用方法

当你有一个新的自动化意图时，向 AI 描述：

```markdown
## 我的意图
{用一句话描述你想自动化的任务}

## 当前手动流程
1. {步骤1}
2. {步骤2}
3. {步骤3}

## 输入来源
- {数据从哪里来}

## 期望输出
- {想要什么格式的输出}

## 特殊要求
- {任何特殊需求}
```

### 转化流程

```
┌─────────────────────────────────────────────────────────────┐
│                    意图 → Skill 转化引擎                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  用户意图                                                    │
│     ↓                                                       │
│  ┌─────────────────┐                                        │
│  │ Phase 1: 探索   │ → 识别阻塞点、确定自动化边界            │
│  └────────┬────────┘                                        │
│           ↓                                                 │
│  ┌─────────────────┐                                        │
│  │ Phase 2: 蓝图   │ → 定义 I/O 契约、设计核心算法           │
│  └────────┬────────┘                                        │
│           ↓                                                 │
│  ┌─────────────────┐                                        │
│  │ Phase 3: 编写   │ → 套用 SKILL.md 标准模板                │
│  └────────┬────────┘                                        │
│           ↓                                                 │
│  ┌─────────────────┐                                        │
│  │ Phase 4: 验证   │ → 验证矩阵测试                          │
│  └────────┬────────┘                                        │
│           ↓                                                 │
│      完整 Skill                                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 六、快速参考卡片

### Frontmatter 必填字段

```yaml
---
name: skill-name          # kebab-case
description: 一句话描述    # 简洁明了
license: MIT              # 或其他
triggers:                 # 语义触发
  - 触发短语1
  - 触发短语2
slash_commands:           # 斜杠命令
  - command: /cmd
    description: 描述
    usage: /cmd args
---
```

### 静默协议检查清单

- [ ] 没有"是否继续？"类询问
- [ ] 没有"请确认"类中断
- [ ] 多选项时有默认值
- [ ] 错误时填备注不中断
- [ ] 仅关键错误才终止

### 输出规范检查清单

- [ ] MD + HTML 双格式
- [ ] 文件名含日期戳
- [ ] 中文输出（除非特殊要求）
- [ ] 最终只输出简明确认

### 验证矩阵模板

| 场景 | 输入 | 预期 | 通过 |
|------|------|------|------|
| 正常 | ✓ | ✓ | ✓ |
| 边缘 | ✓ | ✓ | ✓ |
| 错误 | ✓ | ✓ | ✓ |
| 空值 | ✓ | ✓ | ✓ |

---

## 七、你的 Skill 资产清单

### 已有 Skill（可复用组件）

| 组件 | 来源 Skill | 可复用场景 |
|------|-----------|-----------|
| `fetch_emails.py` | 邮件日报 | 任何 IMAP 邮件处理 |
| `feishu_bitable.py` | 邮件表格 | 任何飞书表格同步 |
| AI Fallback 机制 | 邮件表格 | 任何正则提取任务 |
| 2026 HTML 模板 | 论文解读 | 任何报告生成 |
| 阶段化工作流 | PPT Generator | 复杂多步骤任务 |
| Playwright 持久登录 | 专属播客 | 任何网页自动化 |
| **双报告架构** 🆕 | 海外运营商多维解析 | 同一数据多视角输出 |
| **多层估算模型** 🆕 | 海外运营商多维解析 | 数据缺失时的降级估算 |
| **加权评分系统** 🆕 | 海外运营商多维解析 | 多维度综合评估 |
| **模板驱动报告** 🆕 | 海外运营商多维解析 | 结构化长报告生成 |
| **双视觉风格** 🆕 | 海外运营商多维解析 | 深色科技风 + 商务蓝色风 |
| **6维度分析框架** 🆕⭐ | 元模型更新器 | 任何需要模式识别的场景 |
| **相似度计算算法** 🆕⭐ | 元模型更新器 | 去重、对比、匹配任务 |
| **通用性评分模型** 🆕⭐ | 元模型更新器 | 评估可复用性、价值判断 |
| **元认知引擎** 🆕⭐ | 元模型更新器 | 系统自我分析和进化 |

### 上下文路径索引

| 资源 | 路径 |
|------|------|
| Claude Code 配置 | `~/.claude/` |
| AntiGravity 上下文 | `~/.gemini/antigravity/brain/` |
| 你的 Skills | `/Users/wyw/Project/` |
| 本元模型 | `/Users/wyw/Project/SKILL_META_MODEL.md` |
| Skills 索引 | `/Users/wyw/Project/SKILLS_INDEX.md` |

---

## 八、进阶：Skill 组合模式

### 模式 A: 串联 (Sequential)

```
Skill A 输出 → Skill B 输入 → Skill C 输入
```

**示例**: 邮件获取 → 邮件分析 → 飞书同步

### 模式 B: 并联 (Parallel)

```
         ┌→ Skill A → 输出 A ─┐
输入 ───┼→ Skill B → 输出 B ─┼→ 合并
         └→ Skill C → 输出 C ─┘
```

**示例**: 同时生成 MD/HTML/PDF 三种格式

### 模式 C: 条件分支 (Conditional)

```
输入 → 条件判断 ─┬→ Skill A (条件1)
                ├→ Skill B (条件2)
                └→ Skill C (其他)
```

**示例**: 根据邮件类型选择不同处理逻辑

---

## 九、调校建议

### 如何优化现有 Skill

1. **收集失败案例** — 记录 Skill 处理失败的输入
2. **分析失败原因** — 正则不匹配？AI 误判？
3. **扩展 Few-Shot** — 把失败案例加入示例
4. **增加边缘处理** — 在错误处理中添加新规则
5. **更新验证矩阵** — 把修复后的案例加入测试

### 如何复用到新场景

1. **识别相似模式** — 新任务和哪个现有 Skill 最像？
2. **复制蓝图** — 以最相似的 Skill 为模板
3. **替换核心逻辑** — 修改数据提取和处理算法
4. **保留通用组件** — 静默协议、输出格式等保持不变

---

## 十、最新 Skill 深度分析：海外运营商多维解析 🆕

### Skill 概览

| 属性 | 值 |
|------|-----|
| **名称** | `carrier-analyzer` |
| **路径** | `/Users/wyw/Project/海外运营商多维解析skill/` |
| **SKILL.md** | 1361 行（迄今最详细） |
| **输出文件** | 5 个（双报告 × 双格式 + JSON） |
| **核心算法** | IEPL 4层估算 + 5维度加权评分 |

### 创新亮点

1. **双报告架构**：综合分析（10维度）+ 批发业务分析（8章节）
2. **双视觉风格**：深色毛玻璃（综合）+ 商务蓝色（批发）
3. **4层 IEPL 估算**：直接提取→批发推算→行业对标→AI推理
4. **5维度加权评分**：海缆35% + IEPL30% + 批发20% + 技术10% + 财务5%
5. **并行数据采集**：10个维度独立超时处理
6. **数据质量追踪**：每个维度标注来源和质量等级
7. **详细模板**：`wholesale_template.md` (434行) 确保输出一致

### 可复用的代码片段

**IEPL 估算模型**:
```python
def estimate_iepl_ratio(carrier_data):
    # 层级1-4 降级估算
    ...
```

**加权评分计算**:
```python
def calculate_weighted_score(dimensions):
    weights = {"海缆": 0.35, "IEPL": 0.30, "批发": 0.20, "技术": 0.10, "财务": 0.05}
    return sum(dimensions[k] * weights[k] for k in weights)
```

**风险评分模型**:
```python
def assess_risk(carrier_data):
    # 4维度: 地缘政治30% + 财务30% + 运营20% + 合规20%
    ...
```

---

*本元模型基于你 8 个实战 Skill 的深度分析生成*
*最新更新：2026-02-02（革命性更新：新增"模式 11: 元认知与自我迭代"）*
*🎉 重大里程碑：系统现在具备自我认知和持续进化的能力！*
*持续迭代：每开发一个新 Skill，自动触发"更新元模型"即可*
